/*
 Copyright (c) 2012 Jeremy Wang
 Licensed under the MIT License (LICENSE.txt)
*/

// Euclidean distance
function eucldist(p1, p2) {
    return Math.sqrt(Math.pow((p1[0]-p2[0]), 2) + Math.pow((p1[1]-p2[1]), 2));
}

// Returns a boolean - if the bounding box falls completely outside the current viewing window on the map
function outOfBounds(bbox, map) {
    // bbox = [w, s, e, n]
    return (bbox[0] > map.e || bbox[1] > map.n || bbox[2] < map.w || bbox[3] < map.s)
}

// Mercator projection
function mercator(p) {
    if(p[1] > 85 || p[1] < -85)
        return null;
    // uses the equations for Mercator projection a la http://en.wikipedia.org/wiki/Mercator_projection
    return [p[0], 180/Math.PI * Math.log(Math.tan(Math.PI/4 + p[1]*(Math.PI/180)/2))];
}

function inverse_mercator(p) {
    // inverse of above
    p[1] = (Math.atan(Math.pow(Math.E, p[1] / 180 * Math.PI)) - Math.PI/4) * 2 / (Math.PI/180);
    return p;
}

// Gall-Peters (Gall orthographic) projection
function gallpeters(p) {
    if(p[1] > 85 || p[1] < -85)
        return null;
    // uses the equations for Gall-Peters projection a la http://en.wikipedia.org/wiki/Gall%E2%80%93Peters_projection
    return [p[0], 180/Math.PI * 2*Math.sin(p[1] * Math.PI/180)];
}

function inverse_gallpeters(p) {
    // inverse of above
    p[1] = Math.asin(p[1] / 180 * Math.PI / 2) / Math.PI * 180;
    return p;
}

// Upside-down projection (just for fun)
function upsidedown(p) {
    return [p[0], p[1] * -1];
}

function inverse_upsidedown(p) {
    // inverse of above
    return [p[0], p[1] * -1];
}


/*
{
    'title': 'Boston OSM',
    'left': -71.861,
    'bottom': 42.702,
    'right': -70.285,
    'top': 41.951,
    'stylesheet': 'boston.osm.gss',
    'tiles': {
        '0-': {
            'rows': 1,
            'cols': 1,
            'path': 'boston.osm.tile'
        }
    }
}
*/

function CanvasMap(container, data, style) {
    
    this.layers = [];
    var layer_map = {};
    
    // set projection to be used
    var projection = data['projection'];
    if(projection == 'Mercator') {
        this.project = mercator;
        this.reverse_project = inverse_mercator;
    }
    else if(projection == 'Gall-Peters') {
        this.project = gallpeters;
        this.reverse_project = inverse_gallpeters;
    }
    else if(projection == 'Upside-down') {
        this.project = upsidedown;
        this.reverse_project = inverse_upsidedown;
    }
    else {
        this.project = function(p) { return p; };
        this.reverse_project = this.project;
    }
    
    // Add a control layer to handle mouse interaction including:
    // 1. Detecting the cursor position
    // 2. Dragging to pan
    // 3. Scrolling to zoom
    // Data layers will be stuck in under this layer
    this.control_layer = new ControlLayer(this, container);
    this.control_layer.$canvas.mousedown(attacher(this, function(e) {
        this.drag_x = e.pageX;
        this.drag_y = e.pageY;
        this.drag_y0 = this.y0;
        this.drag_x0 = this.x0;
        this.drag_y1 = this.y1;
        this.drag_x1 = this.x1;
        this.dragging = true;
    }));
    this.control_layer.$canvas.mousemove(attacher(this, function(e) {
        var x_offset = (e.pageX - this.drag_x) / this.zoom;
        var y_offset = (e.pageY - this.drag_y) / this.zoom;
        if(this.dragging) {
            this.update(this.zoom, this.drag_y0+y_offset, this.drag_x0-x_offset, this.drag_y1+y_offset, this.drag_x1-x_offset);
        }
    }));
    this.control_layer.$canvas.mouseup(attacher(this, function(e) {
        this.dragging = false;
    }));
    this.control_layer.$canvas.mousewheel(attacher(this, function(e, delta, deltaX, deltaY) {
        // zoom in
        var newzoom = this.zoom * Math.pow(1.1, delta);
        // compute the new center point in projected coordinates
        var y = (this.y1 - e.pageY/this.zoom) - ($(window).height()/2 - e.pageY) / newzoom;
        var x = (this.x0 + e.pageX/this.zoom) + ($(window).width()/2 - e.pageX) / newzoom;
        var new_center = [y, x];
        this.zoom = newzoom;
        this.resize(null, new_center);
    }));
    this.control_layer.$canvas.click(attacher(this, function(e) {
        // manually propogate click events down through layers
        for(l in this.layers) {
            if(this.layers[l].click) {
                this.layers[l].click(e);
            }
        }
    }));
    
    // pan and changeZoom are updater functions triggered globally by buttons to
    // adjust the viewing window
    this.pan = function(x, y) {
        var projectedWidth = this.width / this.zoom;
        var projectedHeight = this.height / this.zoom;
        var xchange = x * projectedWidth;
        var ychange = y * projectedHeight;
        
        var y0 = this.y0 + ychange;
        var x0 = this.x0 + xchange;
        var y1 = this.y1 + ychange;
        var x1 = this.x1 + xchange;
     
        this.update(null, y0, x0, y1, x1);
    }
    
    this.changeZoom = function(mult) {
        this.zoom *= mult;
        this.resize();
    }

    this.update = function(z, y0, x0, y1, x1) {
        if(z != null)
            this.zoom = z;
        if(y0 != null)
            this.y0 = y0;
        if(x0 != null)
            this.x0 = x0;
        if(y1 != null)
            this.y1 = y1;
        if(x1 != null)
            this.x1 = x1;
            
        // compute geographic bounding coordinates
        var geoPt0 = this.reverse_project([this.x0, this.y0]);
        var geoPt1 = this.reverse_project([this.x1, this.y1]);
        this.geoX0 = geoPt0[0];
        this.geoY0 = geoPt0[1];
        this.geoX1 = geoPt1[0];
        this.geoY1 = geoPt1[1];
        
        for(var l in this.layers) {
            this.redoLayer(l);
        }
    }
    
    this.redoLayer = function(l) {
        this.layers[l].render();
    }
    
    this.hide = function(id) {
        if(id in layer_map) {
            var l = layer_map[id];
            this.layers[l].hide();
            this.redoLayer(l);
            return true;
        }
        return false;
    }
    
    this.show = function(id) {
        if(id in layer_map) {
            var l = layer_map[id];
            this.layers[l].show();
            this.redoLayer(l);
            return true;
        }
        return false;
    }
    
    this.map2screen = function(x, y) {
        var pt = this.project([x,y]);
        x = pt[0];
        y = pt[1];
        x = (x - this.x0) * this.zoom;
        y = (y - this.y0) * this.zoom;
        return [x,y];
    }
    
    // currently unused
    this.screen2map = function(x, y) {
        x = x / this.zoom + this.x0;
        y = y / this.zoom + this.y0;
        var pt = this.reverse_project([x,y]);
        x = pt[0];
        y = pt[1];
        return [x,y];
    }
    
    this.clear = function() {
        for(l in this.layers) {
            this.layers[l].clear();
        }
    }
    
    this.resize = function(event, center) {
        this.width = $(window).width();
        this.height = $(window).height();
        
        this.control_layer.$canvas.attr('width', this.width);
        this.control_layer.$canvas.attr('height', this.height);

        for(var l in this.layers) {
            this.layers[l].$canvas.attr('width', this.width);
            this.layers[l].$canvas.attr('height', this.height);
        }
        var projectedWidth = this.width / this.zoom;
        var projectedHeight = this.height / this.zoom;
        if(center == null)
            center = [this.y0 + (this.y1 - this.y0)/2, this.x0 + (this.x1 - this.x0)/2];
        var y0 = center[0] - projectedHeight / 2;
        var y1 = center[0] + projectedHeight / 2;
        var x0 = center[1] - projectedWidth / 2;
        var x1 = center[1] + projectedWidth / 2;
        this.update(null, y0, x0, y1, x1);
    }
    
    // add layers
    for(var layer in data['layers']) {
        if(data['layers'][layer]['type'] == 'vector') {
            this.layers.push(new TiledLayer(this, container, layer, {'tiles':data['layers'][layer]['tiles'], 'style':style}));
        }
        else if(data['layers'][layer]['type'] == 'gpx') {
            this.layers.push(new GPXLayer(this, container, layer, {'path':data['layers'][layer]['path'], 'style':style, 'tag':[data['layers'][layer]['key'], data['layers'][layer]['val']]}));
        }
        var i = this.layers.length - 1;
        layer_map[layer] = i;
    }
    
    // geographic edge coordinates of the map
    // - while the vertical distance in pixels at one zoom level will remain constant, the distance in degrees will vary because of the projection
    this.n = data['top'];
    this.s = data['bottom'];
    this.w = data['left'];
    this.e = data['right'];
    
    // projected edge coordinates of the viewing window
    var upperleft = this.project([this.w, this.n]);
    var lowerright = this.project([this.e, this.s]);
    this.x0 = upperleft[0];
    this.x1 = lowerright[0];
    this.y0 = lowerright[1];
    this.y1 = upperleft[1];
    this.projectedWidth = this.x1 - this.x0;
    this.projectedHeight = this.y1 - this.y0;
    console.log(this.projectedWidth.toFixed(5) + ' x ' + this.projectedHeight.toFixed(5) + ' (projected)');
    this.zoom = Math.min($(window).height()/this.projectedHeight, $(window).width()/this.projectedWidth); // zoom is relative to the projected coordinate space
    
    // while the size in pixels of the screen will remain constant, the size in degrees may be variable because of the projection
    this.resize(); // adjust for window size at startup
 
    $(window).resize(attacher(this, this.resize));
    console.log('initial zoom: ' + this.zoom.toFixed(2) + 'x');
    
    for(var layer in data['layers'])
        this.show(layer);
}


function ControlLayer(map, container) {
    this.$canvas = $('<canvas>');
    this.$canvas.addClass('layer');
    $(container).append(this.$canvas);
    this.$canvas.attr('width', this.$canvas.width());
    this.$canvas.attr('height', this.$canvas.height());
    this.ctx = this.$canvas.get(0).getContext('2d');
    
    this.map = map;
}

// there is actually only ever one layer
function TiledLayer(map, container, id, data) {
    
    this.$canvas = $('<canvas>');
    this.$canvas.addClass('layer');
    this.$canvas.insertBefore(map.control_layer.$canvas);
    this.$canvas.attr('width', this.$canvas.width());
    this.$canvas.attr('height', this.$canvas.height());
    this.ctx = this.$canvas.get(0).getContext('2d');
    
    var hidden = true;
    this.hide = function() {
        hidden = true;
        this.clear();
    }
    this.show = function() {
        hidden = false;
    }
    this.visible = function() {
        return !hidden;
    }
    
    this.clear = function() {
        this.ctx.clearRect(0, 0, this.$canvas.width(), this.$canvas.height());
    }
    
    this.render = function() {
        if(hidden) {
            return;
        }
        this.clear();
        for(var i in resolutions) {
            var r = resolutions[i][0]
            var tilesize = Math.max((this.map.e-this.map.w) / resolutions[i][1]['rows'], (this.map.n-this.map.s) / resolutions[i][1]['cols']); // we assume here that tiles are square, mostly
            var filepath = resolutions[i][1]['path'];
            if(r <= this.map.zoom) {
                var lastrow = Math.min(Math.ceil((this.map.n-this.map.s)/tilesize)-1, parseInt((this.map.n - this.map.geoY0) / tilesize));
                var lastcol = Math.min(Math.ceil((this.map.e-this.map.w)/tilesize)-1, parseInt((this.map.geoX1 - this.map.w) / tilesize));
                var firstrow = Math.max(0, parseInt((this.map.n - this.map.geoY1) / tilesize));
                console.log(this.map.n, '-', this.map.geoY1, '/', tilesize, '=', firstrow);
                console.log((this.map.n - this.map.geoY1)/2);
                if(typeof this.map.n == typeof 1)
                    console.log('n is int');
                if(typeof this.map.geoY1 == typeof 1)
                    console.log('geoY1 is int');
                var firstcol = Math.max(0, parseInt((this.map.e + this.map.geoX0) / tilesize));
                console.log('tilesize', tilesize);
                console.log(this.map.w, 'w', this.map.s, 's ->', this.map.e, 'e', this.map.n, 'n');
                console.log(this.map.geoX0, 'x0', this.map.geoY0, 'y0 ->', this.map.geoX1, 'x1', this.map.geoY1, 'y1');
                console.log('loading resolution', r, ',', firstrow, '->', lastrow, ' x ', firstcol, '->', lastcol);
                for(var row = firstrow; row <= lastrow; row++) {
                    for(var col = firstcol; col <= lastcol; col++) {
                        if(tiles[r][row][col] && tiles[r][row][col].loaded) {
                            tiles[r][row][col].render(this.map, this.ctx)
                        }
                        else {
                            if (!tiles[r][row][col]) {
                                console.log('loading tile ' + row + ', ' + col);
                                tiles[r][row][col] = new VectorTile('data/'+filepath.replace('[x]', col).replace('[y]', row), styles,
                                    attacher(this, function(t){t.render(this.map, this.ctx);}));
                            }
                        }
                    }
                }
                break; // determining when and how to show lower resolutions while loading, etc, is much more complicated with layers, so right now we'll just never show old resolutions
            }
        }
    }

    this.map = map;
    this.id = id;

    var styles = data['style'];
    
    var resolutions = [];
    // flatten the dictionary to a list
    for(var r in data['tiles'])
        resolutions.push([parseInt(r), data['tiles'][r]]);
    // sort resolutions from highest to lowest
    resolutions.sort(function(a,b){return b[0]-a[0]});

    // this will be a sparse array with only indices with known resolutions filled
    // each resolution will have an array of (row x col) tiles
    var tiles = [];
    for(var i in resolutions) {
        var res = resolutions[i][0];
        var rows = resolutions[i][1]['rows'];
        //var cols = resolutions[i][1]['cols'];
        tiles[res] = [];
        for(var y = 0; y < rows; y++) {
            tiles[res][y] = [];
        }
                
    }
}

function VectorTile(filepath, style, loadback) {
    
    var polys = {};
    var labels = {};
    var renderer = null;
    this.loaded = false;
    
    // get the index of the polygon at the given pixel coordinates (x,y)
    this.atCoord = function(x, y) {
        return null;
    }
    
    this.load = function(read_data) {
        for(var d = 0; d < read_data.length; d++) {
            var v = read_data[d];
            // make a double nested vector type hash
            if(!polys[v[1]])
                polys[v[1]] = {};
            if(!polys[v[1]][v[2]])
                polys[v[1]][v[2]] = [];
                
            if(!labels[v[1]])
                labels[v[1]] = {};
            if(!labels[v[1]][v[2]])
                labels[v[1]][v[2]] = [];
                
            if(v[0] == 0) { // polygon
                // construct the points array
                // (points in the file are offset and scaled - these need to be undone)
                var pts = [];
                for(var p = 0; p < v[6].length; p+=2) {
                    pts.push([v[6][p] / v[5] + v[3], v[6][p+1] / v[5] + v[4]]);
                }
                polys[v[1]][v[2]].push(pts);
            }
            
            else if(v[0] == 1) { // label
                labels[v[1]][v[2]].push([v[3], v[4], v[5]]);
            }
        }
        this.loaded = true;
        
        renderer = new VectorRenderer(style, polys, labels);
        loadback(this);
    }
    
    this.render = function(map, ctx) {
        renderer.render(map, ctx);
    }
    
    // fetch the JSON data
    var handle = {
        'callback': attacher(this, function(data) {
            this.load(data);
        }),
        'error': function(msg) {
            console.log(msg);
        }
    };
    JSON(filepath, handle, {});
}

// there is actually only ever one layer
function GPXLayer(map, container, id, data) {
    
    this.$canvas = $('<canvas>');
    this.$canvas.addClass('layer');
    this.$canvas.insertBefore(map.control_layer.$canvas);
    this.$canvas.attr('width', this.$canvas.width());
    this.$canvas.attr('height', this.$canvas.height());
    this.ctx = this.$canvas.get(0).getContext('2d');
    
    var hidden = true;
    this.hide = function() {
        hidden = true;
        this.clear();
    }
    this.show = function() {
        hidden = false;
    }
    this.visible = function() {
        return !hidden;
    }
    
    this.clear = function() {
        this.ctx.clearRect(0, 0, this.$canvas.width(), this.$canvas.height());
    }
    
    this.render = function() {
        if(hidden) {
            return;
        }
        this.clear();
        if(tile && tile.loaded) {
            tile.render(this.map, this.ctx);
        }
        else if (tile == null) {
            tile = new GPXTile(path, styles, data['tag'], attacher(this, function(t){t.render(this.map, this.ctx);}));
        }
    }

    this.map = map;
    this.id = id;

    var styles = data['style'];
    var path = data['path'];
    var tile = null;
}

function GPXTile(filepath, style, tag, loadback) {
    
    var polys = {};
    var renderer = null;
    this.loaded = false;
    
    /*
    Format:
    
    [ name, [[[multiplier, [[pt0x, pt0y], [pt1x, pt1y] ...]], [multiplier, [pt0m, pt1m, pt2m ...]], [multiplier, [pt0ms, pt1ms ...]]] ...] ] 
    
    (all delta-encoded)
    */
    
    this.load = function(read_data) {
        console.log(read_data);
        var caption = read_data[0];
        
        // the entire GPX is a single feature-type
        if(!polys[tag[0]])
            polys[tag[0]] = {};
        if(!polys[tag[0]][tag[1]])
            polys[tag[0]][tag[1]] = [];
        
        for(var d = 0; d < read_data[1].length; d++) {
            var components = read_data[1][d]; // pts, elevation, time
            
            var line = components[0];
            // construct the points array
            // (points in the file are offset and scaled - these need to be undone)
            var pts = [];
            var lastpt = [0,0];
            for(var p = 0; p < line[1].length; p++) {
                pts.push([line[1][p][0] / line[0] + lastpt[0], line[1][p][1] / line[0] + lastpt[1]]);
                lastpt = pts[p];
            }
            polys[tag[0]][tag[1]].push(pts);
        }
        this.loaded = true;
        
        console.log(polys);
        
        renderer = new VectorRenderer(style, polys);
        loadback(this);
    }
    
    this.render = function(map, ctx) {
        renderer.render(map, ctx);
    }
    
    var handle = {
        'callback': attacher(this, this.load),
        'error': function(msg) {
            console.log(msg);
        }
    };
    GPX('data/'+filepath, handle);
}

function VectorRenderer(style, polys, labels) {
    this.render = function(map, ctx) {
        for(var key in polys) {
            for(var val in polys[key]) {
                // draw polygons
                ctx.save();
                // set styles
                var fill = false;
                var stroke = false;
                if(style[key] && style[key][val]) {
                    for(var s in style[key][val]['poly']) {
                        ctx[s] = style[key][val]['poly'][s];
                        if(s == 'fillStyle')
                            fill = true;
                        if(s == 'strokeStyle')
                            stroke = true;
                    }
                }
                else if(style['default']) {
                    for(var s in style['default']['poly']) {
                        ctx[s] = style['default']['poly'][s];
                        if(s == 'fillStyle')
                            fill = true;
                        if(s == 'strokeStyle')
                            stroke = true;
                    }
                }
                
                // XKCD graphics
                var x = new xkcd(ctx, 0.7, 20); //ctx, jitter, scale
                // EX: x.line([[0,400], [500,400]], '#000000', 4);
                for(var d = 0; d < polys[key][val].length; d++) {
                    var pts = polys[key][val][d];
                    var mapped_pts = [];
                    for(var p = 0; p < pts.length; p++) {
                        var coords = map.map2screen(pts[p][0], pts[p][1]);
                        mapped_pts.push([coords[0], map.height-coords[1]]);
                    }
                    x.line(mapped_pts); // draw it !!!
                    if(fill) {
                        ctx.fill();
                    }
                    if(stroke) {
                        ctx.stroke();
                    }
                }
                
                /*
                // draw vectors
                for(var d = 0; d < polys[key][val].length; d++) {
                    var pts = polys[key][val][d];
                    ctx.beginPath();
                    //console.log(pts[0][0], pts[0][1], map.s);
                    var coords = map.map2screen(pts[0][0], pts[0][1]);
                    //if(d == 0)
                    //    console.log(coords[0], coords[1]);
                    ctx.moveTo(coords[0], map.height - coords[1]);
                    for(var pt = 1; pt < pts.length; pt++) {
                        coords = map.map2screen(pts[pt][0], pts[pt][1]);
                        ctx.lineTo(coords[0], map.height - coords[1]);
                    }
                    if(fill) {
                        ctx.fill();
                    }
                    if(stroke) {
                        ctx.stroke();
                    }
                }
                */
                ctx.restore();
                
                // draw labels
                ctx.save();
                // set styles
                var fill = false;
                var stroke = false;
                if(style[key] && style[key][val]) {
                    for(var s in style[key][val]['label']) {
                        ctx[s] = style[key][val]['label'][s];
                        if(s == 'fillStyle')
                            fill = true;
                        if(s == 'strokeStyle')
                            stroke = true;
                    }
                }
                else if(style['default']) {
                    for(var s in style['default']['label']) {
                        ctx[s] = style['default']['label'][s];
                        if(s == 'fillStyle')
                            fill = true;
                        if(s == 'strokeStyle')
                            stroke = true;
                    }
                }
                for(var d = 0; d < labels[key][val].length; d++) {
                    var label = labels[key][val][d];
                    coords = map.map2screen(label[1], label[2]);
                    if(fill)
                        ctx.fillText(label[0], coords[0], map.height - coords[1]);
                    if(stroke)
                        ctx.strokeText(label[0], coords[0], map.height - coords[1]);
                }
                ctx.restore();
            }
        }
    }
}

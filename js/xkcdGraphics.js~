// Jeremy Wang
// Oct 10, 2012

function xkcd(ctx, jitter, scale) {

    this.line = function(pts) {
        pts = breakLine(pts);
        path(pts);
    }

    var breakLine = function(pts) {
        var newpts = [[pts[0][0], pts[0][1], false]]; // true:false indicates if this point should be fixed (not jittery)
        for(var p = 1; p < pts.length; p++) {
            var xdist = pts[p][0]-pts[p-1][0];
            var ydist = pts[p][1]-pts[p-1][1];
            var dist = Math.sqrt(Math.pow(xdist, 2) + Math.pow(ydist, 2)); // euclidean distance
            var blocks = dist / scale;
            for(var i = 1; i < blocks; i++) {
                newpts.push([pts[p-1][0] + xdist/blocks*i, pts[p-1][1] + ydist/blocks*i, false]);
            }
            
            /*
            // introduce some variation in end point position
            if(p < pts.length-1) {
                newpts.push([pts[p][0], pts[p][1], true]);
                newpts.push([pts[p][0] + rnd_snd() * jitter * dist/scale, pts[p][1] + rnd_snd() * jitter * dist/scale, false]);
            }
            */
            
            // add jitter for end points here
            // multiply jitter by (dist/scale) to reduce total jitter allowed for very small segments)
            if(p < pts.length-1)
                newpts.push([pts[p][0] + rnd_snd() * jitter * Math.min(dist/scale, 1), pts[p][1] + rnd_snd() * jitter * Math.min(dist/scale, 1), true]); // true: fixed pt
            else
                newpts.push([pts[p][0], pts[p][1], false]);
        }
        return newpts;
    }
    
    var path = function(pts) {
        var len = pts.length;
	
	    pts_mod = [];
	    for(var i = 0; i < pts.length; i++) {
	        if(!pts[i][2])
        	    pts_mod.push([pts[i][0] + rnd_snd() * jitter, pts[i][1] + rnd_snd() * jitter]);
        	else
        	    pts_mod.push([pts[i][0], pts[i][1]]);
	    }
	
        ctx.lineJoin = 'round';
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(pts_mod[0][0], pts_mod[0][1]);
        for(var i = 1; i < pts_mod.length; i++) {
            ctx.lineTo(pts_mod[i][0], pts_mod[i][1]);
        }
    }
    
    this.text = function(txt, x, y, fontsize) {
        ctx.font = "normal " + fontsize + "pt XKCD";
	    var w = ctx.measureText(leaves[l]).width;
    	ctx.fillText(txt, x, y);
    	
    	return w;
    }
}

// approximates a normal distribution mu = 0, sigma = 1 without too much math
function rnd_snd() {
    return (Math.random()*2-1)+(Math.random()*2-1)+(Math.random()*2-1);
}

